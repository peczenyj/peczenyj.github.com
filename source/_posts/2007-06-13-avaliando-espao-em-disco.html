---
layout: post
title: "Avaliando Espaço em Disco"
date: 2007-06-13T17:19:00-03:00
categories:
 - Linux
 - Shell
---

<div class='post'>
Um problema comum de qualquer administrador é o espaço em disco. As politicas de quotas geralmente resolvem boa parte destes problemas, é claro, mas nem sempre são suficientes.<br /><br />O caso: pensando de forma genérica, diversas pessoas criam diretórios de trabalho dentro do bom e velho/local e, com o passar do tempo, esta partição pode lotar e comprometer o trabalho de todos. Politicas de uso racional do espaço em disco podem ser aplicadas mas as vezes a coisa pode sair do controle -- nesse caso o prejuizo pode ser grande.<br /><br />Os diretorios possuem o seguinte formato:<br /><pre>/local/diretorio/algum_nome_identificador.vws</pre><br /><br />Vamos recorrer ao bom e velho Shell-Script para investigar se existe algum problema em andamento!<br /><br /><pre>$ df /local<br />Filesystem           1K-blocks      Used Available Use% Mounted on<br />/dev/sdb1             35001508  11330452  21893064  35% /local</pre><br /><br />Vejam só: apenas 35% da partição está sendo ocupada e isso não representa risco neste momento. Se estivesse acima de 80% alguma medida perventiva deveria ser tomada. Como podemos fazer este teste? Existem varias formas, vou usar o poder das expressões regulares para isso!<br /><br /><pre><code>$ seq -f"%g%%" 10 5 100 | grep -E '(100|[89][0-9])%'<br /><br />80%<br />85%<br />90%<br />95%<br />100%</code></pre><br /><br />A expressão usada no grep casa com valores de porcentagem acima de 80% (inclusive), logo podemos usar em um teste simples<br /><br /><pre><code> if df /local | grep -qE '(100|[89][0-9])%' ; then<br />     echo '/local [quase] lotado!'<br /> else<br />     echo '/local seguro (menos de 80%)'<br /> fi</code></pre><br /><br />Simples, não? Poderia ter usado os operadores && e || mas não queria sacrificar a legibilidade do código.<br /><br />Agora vem a parte divertida: e se o /local estiver ficando cheio, vamos fazer o que?<br /><br />Quando vc não tem a responsabilidade de apagar arquivos desnecessários, o maximo que vc pode fazer é avisar os responsáveis. Elaborar um relatório com os 'problemas' encontrados e enviar por email usando shell script é simples.<br /><br />Vamos usar o du para calcular o espaço gasto em cada diretório e o sort para ordenar do maior para o menor tamanho total.<br /><br /><pre><code>$ du -bs /local/diretorio/* 2>&- | sort -nr <br />3765643919      /local/diretorio/nonono001.vws<br />2290883178      /local/diretorio/nonono002.vws<br />2067295469      /local/diretorio/nonono003.vws<br />932165874       /local/diretorio/nonono004.vws<br />...<br />267271  /local/viewstore1/nonono999.vws</code></pre><br /><br />Facil heim ? Se vc se dá ao trabalho de ler as man pages do du e do sort, basta fazer algumas experiências até obter o resultado que mais lhe agrada. Por exemplo, uma atitude interessante seria listar os X maiores diretórios e enviar por email para o administrador.<br /><br /><pre><code>$ du -bs /local/diretorio/* 2>&- | sort -nr | head -10 > /tmp/arquivo.log <br />$ mailx -S "Lista dos 10 maiores diretorios" "administrador@server" <  /tmp/arquivo.log</code></pre><br /><br />Talvez vc pergunte o motivo pelo qual eu utilizo um arquivo temporário: caso o envio do email dê algum problema, é possivel recuperar a lista.<br /><br />Um script para rodar na cron e enviar o email de forma automatizada teria este formato:<br /><br /><pre><code>#!/bin/bash<br /># Autor: Tiago Peczenyj - 13/jun/2007<br /># Script parametrizado para avaliar tamanho de alguns diretorios<br /><br />X=10<br />DIR=/local/diretorio<br />EMAIL=administrador@server<br />SUBJECT="Lista dos ${X} maiores diretorios em $(date +"%Y%m%d" )"<br />if df ${DIR} | grep -qE '(100|[89][0-9])%' ; then<br />     du -bs ${DIR}/* 2>&- | sort -nr | head -${X} > /tmp/arquivo.log <br />     mailx -S "${SUBJECT}" ${EMAIL} <  /tmp/arquivo.log<br />fi</code></pre><br /><br />O script parece simples, entretanto algo simples como informar o usuario dono de cada diretório é muito mais complexo. A minha solução foi esta:<br /><br /><code><pre>paste -d '\t' <(du -bs /local/viewstore1/* 2>&-) \<br /><(ls -l /local/viewstore1 | awk '/^d/{print $3}') | awk '{<br />      OFS="\t" ; print $1,$3,$2<br />}'| sort -nr</code></pre></div>
